
/*
Bongo.js
Unfancy models for MongoDB

(c) 2011 Koding, Inc.

@module: bongo-client
@author: Christopher Thorn <chris@koding.com>
*/

var bongo, global, isBrowser;
var __slice = Array.prototype.slice, __hasProp = Object.prototype.hasOwnProperty;

global = global || this;

/*
@snippet.
@description: feature-detect the browser.
@todo: is there an improvement?
*/

isBrowser = 'undefined' != typeof window && window === global;

/*
@class: bongo (client)
@description: client-side bongo.
*/

bongo = (function() {
  var EventEmitter, Model, Traverse, api, clientId_, createConstructor, createId, dnode, extend, slice, wrapAll, wrapFn;

  function bongo() {}

  EventEmitter = require('events').EventEmitter;

  Traverse = require('traverse');

  createId = bongo.createId = require('hat');

  dnode = require('dnode');

  bongo = new EventEmitter;

  slice = [].slice;

  extend = function() {
    var key, obj, rest, source, val, _i, _len;
    obj = arguments[0], rest = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    for (_i = 0, _len = rest.length; _i < _len; _i++) {
      source = rest[_i];
      for (key in source) {
        val = source[key];
        obj[key] = val;
      }
    }
    return obj;
  };

  bongo.Model = Model = (function() {

    function Model() {}

    Model.prototype.set = function(data) {
      return extend(this, data);
    };

    return Model;

  })();

  bongo.api = {};

  if (!isBrowser) bongo.browserPath = "" + __dirname + "/browser";

  createConstructor = function(name, staticMethods, instanceMethods) {
    var constructor, method, methodName, _fn, _fn2;
    constructor = Function('createId', "return function " + name + " (data) {\n  data || (data = {});\n  if (!('bongo_' in data)) {\n    this.bongo_ = {\n      instanceId: createId(),\n      constructorName: \"" + name + "\"\n    };\n  }\n  this.set(data);\n}")(createId);
    _fn = function(methodName, method) {
      return constructor[methodName] = function() {
        var args;
        args = slice.call(arguments);
        wrapAll(args);
        return method.apply(constructor, args);
      };
    };
    for (methodName in staticMethods) {
      if (!__hasProp.call(staticMethods, methodName)) continue;
      method = staticMethods[methodName];
      _fn(methodName, method);
    }
    constructor.prototype = new Model;
    _fn2 = function(methodName, method) {
      return constructor.prototype[methodName] = function() {
        var args;
        args = slice.call(arguments);
        wrapAll(args);
        method.apply(null, [this].concat(__slice.call(args)));
        return this;
      };
    };
    for (methodName in instanceMethods) {
      if (!__hasProp.call(instanceMethods, methodName)) continue;
      method = instanceMethods[methodName];
      _fn2(methodName, method);
    }
    return constructor;
  };

  wrapAll = function(obj) {
    new Traverse(obj).forEach(function(node) {
      if ('function' == typeof node) return this.update(wrapFn(node, true));
    });
  };

  wrapFn = function(fn) {
    var context;
    context = this;
    return function() {
      var args;
      args = slice.call(arguments);
      new Traverse(args).forEach(function(node) {
        var model;
        if (!this.isLeaf && 'bongo_' in node) {
          return model = new bongo.api[node.bongo_.constructorName](node);
        }
      });
      fn.apply(context, args);
      return this;
    };
  };

  clientId_ = (typeof localStorage !== "undefined" && localStorage !== null ? localStorage.clientId : void 0) ? localStorage.clientId : (clientId_ = createId(), typeof localStorage !== "undefined" && localStorage !== null ? localStorage.clientId = clientId_ : void 0);

  api = {
    receiveServerError: function(errMsg) {
      throw new Error("An error was reported by the server: " + errMsg);
    },
    receiveAccessError: function(errMsg) {
      return KD.requireLogin(errMsg);
    },
    fetchClientId: function(callback) {
      return callback(clientId_);
    },
    receiveBroadcast: function(broadcast) {
      return bongo.emit('broadcast', broadcast);
    }
  };

  bongo.expose = function(source) {
    var obj, prop;
    for (prop in source) {
      if (!__hasProp.call(source, prop)) continue;
      obj = source[prop];
      if ((api[prop] != null) && 'object' === typeof obj) {
        api[prop] = extend(api[prop], obj);
      } else {
        api[prop] = obj;
      }
    }
    return this;
  };

  bongo.connect = function(port, callback) {
    var client, _ref;
    if (!callback) _ref = [port, callback], callback = _ref[0], port = _ref[1];
    client = dnode(api);
    client.connect(port, function(remote) {
      return remote.fetchApi(function(constructors, globals) {
        var fn, instanceMethods, name, staticMethods, _i, _len, _ref2;
        for (name in globals) {
          if (!__hasProp.call(globals, name)) continue;
          fn = globals[name];
          if ((global[name] != null) && 'object' === typeof global[name]) {
            global[name] = extend(global[name], globals[name]);
          } else {
            global[name] = globals[name];
          }
        }
        for (_i = 0, _len = constructors.length; _i < _len; _i++) {
          _ref2 = constructors[_i], name = _ref2.name, staticMethods = _ref2.staticMethods, instanceMethods = _ref2.instanceMethods;
          bongo.api[name] = createConstructor(name, staticMethods, instanceMethods);
        }
        return callback(bongo.api);
      });
    });
    return this;
  };

  return bongo;

})();

/*
@snippet.
@description: export for node, or the browser, depending.
*/

if (!isBrowser && module) {
  module.exports = bongo;
} else {
  this.bongo = bongo;
}
